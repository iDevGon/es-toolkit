/**
 * Maps each element in a collection to a new array of values using an iteratee.
 *
 * This function takes a collection (either an array or an object) and applies
 * a mapping function (iteratee) to each element or value. It returns a new array
 * of values generated by the iteratee. If no iteratee is provided, the identity
 * function is used, meaning the values themselves are returned.
 *
 * @template T The type of elements or values in the collection.
 * @template U The type of elements in the resulting array.
 * @param {T[] | Record<string, T> | number | string | boolean | null | undefined} collection
 *        The collection to iterate over. It can be an array, an object, or a primitive.
 *        If the collection is null or undefined, an empty array is returned.
 * @param {((value: T, key: string | number) => U) | keyof T | null} [iteratee=null]
 *        The function invoked per iteration. If a key of the collection elements is
 *        provided instead of a function, the value of that key will be returned for
 *        each element.
 * @returns {U[]} A new array of values mapped by the iteratee or by the identity function.
 *
 * @example
 * // Maps an array of numbers by multiplying each by 2
 * map([1, 2, 3], n => n * 2);
 * // Returns: [2, 4, 6]
 *
 * @example
 * // Maps an object, extracting the values of the 'name' property
 * map({ a: { name: 'John' }, b: { name: 'Jane' } }, 'name');
 * // Returns: ['John', 'Jane']
 *
 * @example
 * // If the collection is null or undefined, returns an empty array
 * map(null);
 * // Returns: []
 */
export function map<T, U>(
  collection: T[] | Record<string, T> | number | string | boolean | null | undefined,
  iteratee?: ((value: T, key: string | number) => U) | keyof T | null
): U[] {
  if (collection == null || typeof collection !== 'object') {
    return [];
  }

  const mapper: (value: T, key: string | number) => U =
    typeof iteratee === 'function'
      ? iteratee
      : iteratee == null
        ? (item: T) => item as unknown as U
        : (item: T) => item[iteratee as keyof T] as unknown as U;

  if (Array.isArray(collection)) {
    const length = collection.length;
    const result: U[] = new Array(length);
    for (let i = 0; i < length; i++) {
      result[i] = mapper(collection[i], i);
    }
    return result;
  } else {
    return Object.keys(collection).map(key => mapper(collection[key], key));
  }
}
